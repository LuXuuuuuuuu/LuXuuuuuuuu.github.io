{"posts":[{"title":"计算机组成原理","content":"第七章 存储器层次结构 7.1存储器概述 7.1.1存储器的分类 1.按存储元件分类 半导体存储器 磁性材料存储器 光介质存储器。 2.按存取方式分类 随机存取存储器（RAM） 顺序存取存储器（SAM） 直接存取存储器（DAM） 3.按信息的可更改性分类 按信息的可更改性分为可读可写存储器和只读存储器(read only memory,ROM)。 ROM中的信息一旦确定，通常情况下只读不写，但在某些情况下也可重新写入。RAM是 一种可读可写存储器，RAM和ROM都采用随机存取方式进行信息的访问。 4.按断电后信息的可保存性分类 7.1.2 主存储器的组成和基本操作 7.1.3存储器的层次化结构 数据一般只在相邻两层之间复制传送，而且总是从慢速存储器复制到快速存储器才能被使用。 7.2 半导体随机存取存储器 半导体 RAM具有体积小、存取速度快等优点，因而适合作为内部存储器使用 半导体RAM 双极型RAM MOS型RAM 静态RAM（SRAM） 动态RAM（DRAM） 7.2.1 基本存储元件 用来存储一位二进制信息 1.六管静态MOS管存储元件 A高电平，B低电平存1 B高电平，A低电平存2 保持：W上加低电平 读出： 在两个位线，字选择线上加高电平 检测位线负脉冲 写入 字选择线上加高电平 若要写1,则在位线 D1上加低电平，使B点电位下降，T1管截止，A点电位上升，使T2管导通完成写1。 若要写0,则在D0线上加低电平，使A点电位下降，T2管截止，B点电位上升，T1管导通，完成写0。 2.单管动态MOS 管存储元件 读出（破坏性读出） 字选择线W加选通脉冲 写入 写1时，在数据线上加高电平，经T管对Cs充电 写0时，在数据线上加低电平，Cs充分放电 刷新 定时对Cs充电 3.静态存储元件和动态存储元件比较 7.2.2 SRAM芯片和DRAM芯片 存储器芯片由存储体，I/O读写电路，地址译码和控制电路等部分组成 存储体（存储矩阵）：存储单元的集合 地址译码器：将地址转换为译码输出线上的高电平，有一维译码和二维译码两种方式 一维译码 适用于小容量的静态存储器 只有一个行译码器 二维译码 适用于容量较大的动态存储器 有4096个单元，需要12根地址线？？？？ 驱动器（译码器后加驱动器） I/O控制电路：用于控制被选中单元的读出或写入，具有放大信息的作用 片选控制信号CS 读写控制信号WE 4M*4位DRAM芯片示意图 （a） 11根地址引脚线A0-A10 四根数据引脚线D1-D4 RAS行选通信号 CAS列选通信号 WE读写控制引脚 OE输出使能驱动引脚（低电平有效，高电平断开输出） 刷新时只给各芯片送行地址和RAS信号，芯片中某一行的所有元被选中并进行读操作——读出零则充分放电，一则进行充电 7.2.3 SDRAM芯片技术 1.SDRAM芯片技术 传统的 ","link":"https://luxuuuuuuuu.github.io/post/ji-suan-ji-zu-cheng-yuan-li/"},{"title":"数据结构","content":"第二章 算法分析 2.1 数学基础 O Ω θ 将常数或低阶项放进大O是非常坏的习惯 N的增长要快于log的任意次幂 2.2 模型 2.3 要分析的问题 作为一个例子，我们将在下一节考虑下述问题： 最大子序列和问题 2.4 运行时间计算 2.4.1 一个简单的例子 所有的生命不占时间 第一行和第四行各占一个时间单元 第三行每执行一次占四个单元（两次乘法，一次加法，一次赋值） i的自增运算，初始化i，测试i大小隐藏开销（初始化1，测试N+1，自增N 2.4.2 一般法则 public static long factorial(int n){ if(n&lt;=1){ return 1; }else{ return n * factorial(n-1); } } //很显然，运行时间为O（n） //我们再看一个例子 public static long fib(int n){ if(n &lt;= 1){ return 1; }else{ return fib(n-1)+fib(n-2); } } 2.4.3 最大子序列和问题的求解 算法一：（暴力） public static int maxSubSum1(int[] a){ int maxSum=0; for(int i=0;i&lt;a.length;i++){ for(int j=i; j&lt;a.length;j++) { int thisSum = 0; for(int k = i;k&lt;=j;k++){ thisSum+=a[k]; } if(thisSum&gt;maxSum){ maxSum=thisSum; } } } return maxSum; } 算法二 public static int maxSubSum2(int[] a){ int maxSum=0; int n=a.length; for(int i=0;i&lt;=n;i++){ int thisSum=0; for(int j=i;j&lt;=n;j++){ thisSum+=a[j]; if(thisSUm&gt;maxSum){ maxSum=thisSum; } } return maxSum; } 算法三（分治） private static int maxSamRec(int[] a,int left;int right){ if(left==right) if(a[left]&gt;0){ return a[left]; }else{ return 0; } int center=(left+right)/2; int maxLeftSum = maxSumRec(a,left,center); int maxRightSum = maxSumRec(a,center+1,right); int maxLeftBorderSum=0;,leftBorderSum=0; for(int i=center;i&gt;=left;i--){ leftBorderSum+=a[i]; if(leftBorderSum&gt;maxLeftBorderSum){ maxLeftSum=leftBorderSum; } } int maxRightBorderSum=0;rightBorderSum=0; for(int i=center;i&lt;=right;i++){ rightBorderSum+=a[i]; if(rightBorderSum&gt;maxRightBorderSum){ maxRightSum=rightBorderSum; } } return max3(maxLeftsum,maxRightSum,maxLeftBorderSum+maxRightBorderSum); } 算法四 public static int maxSubSum4(int[] a){ int maxSum=0,thisSum=0; for(int j=0;j&lt;a.length;j++){ thisSum+=a[j]; if(thisSum&gt;maxSum) maxSum=thisSum; else if(thisSum&lt;0) thisSum=0; } return maxSum; } 这种算法称作联机算法 2.4.4 运行时间中的对数 三个例子 折半查找（binary search） 欧几里得算法 幂运算 ","link":"https://luxuuuuuuuu.github.io/post/shu-ju-jie-gou/"},{"title":"计算机网络（谢希仁)","content":"第三章 数据链路层 3.2 点对点协议PPP 3.2.1 PPP协议的特点 应满足的需求 协议的组成 将IP数据报封装到串行链路的方法 链路控制协议LCP（用来建立，配置和测试数据链路连接） 网络控制协议NCP PPP协议的帧格式 各字段的意义 字节填充 零比特填充（只要出现五个连续的一，就填充一个零） PPP协议的工作状态 3.3 使用广播信道的数据链路层 3.2.1 局域网的数据链路层 3.3.2 CSMA/CD协议 多点接入 载波监听 碰撞检测 显然，在使用CSMA/CD协议时，一个站不可能同时发送和接收，即不可能进行全双工通信而只能进行半双工通信。 3.3.3 使用集线器的星形拓扑 集线器： 物理上星形；逻辑上总线 有许多接口，很像一个多接口的转发器 工作在物理层，仅仅简单的转发比特，不进行碰撞检测（若两个接口同时有信号输入，则所有的接口都收不到正确的帧 3.3.4 以太网的信道利用率 扣除碰撞造成的信道损失后，以太网的总的信道利用率并不能达到%100 要提高以太网的的信道利用率，就必须减小t与T0之比 3.3.5 以太网的MAC层 MAC层的硬件地址 “名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处” 严格的讲，局域网的地址应当是每一个站的“名字”或标识符 现在的局域网适配器实际上使用的都是6字节的MAC地址 前三个字节（OUI，组织唯一标识符，也叫公司标识符company_id） 后三个字节是扩展标识符（extended identifier） 最低位：I/G位（individual/group）： I/G为一表示组地址，用来进行多播 为零时表示一个单个站地址 MAC帧的格式 前同步码：使接收端的适配器在接收MAC帧时迅速调整时钟频率，使其与发送端的时钟同步 无效帧 Q1：MAC子层如何知道从接收到的的以太网帧中取出多少字节的数据交付给上一层协议？？？ Q2：填充问题 ATTENTION 3.4 扩展的以太网 3.4.1 在物理层扩展以太网 转发器 光纤 3.4.2 在数据链路层扩展以太网 1.以太网交换机的特点 最初用网桥 交换式集线器（交换机）： 每个接口连主机或交换机 一般都工作在全双工方式 具有并行性，能同时连接多对接口 相连的主机独占传输媒体，无碰撞的进行通信 自学习建立交换表 优点 直通（cut-through)：不必缓存数据帧，缺点是不检查差错 2.以太网交换机的自学习功能 冗余链路导致的无限制兜圈问题 利用生成树协议STP，保证主机之间的路径是无环路的树状结构 3.4.3 虚拟局域网 3.5 高速以太网 略 第四章 网络层 4.1 网络层提供的两种服务 网络层向上只提供灵活的，无连接的，尽最大努力交付的数据报服务 网络层不提供服务质量的承诺 4.2 网际协议IP 4.2.1 虚拟互连网络 网络互连需要解决的问题 注：有时把网络层使用的路由器称为网关 互联网可以由多种异构网络互连组成 4.2.2 分类的IP地址 IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32位的标识符 IP地址的三个阶段 （1）分类的IP地址 （2）子网的划分 （3）构成超网 IP地址不仅仅指明一台主机，还指明了主机所连接到的网络 IP地址中的全0表示”这个（this）“，网络号字段为全0的IP地址表示本网络。 网络号为01111111保留作为本地环回测试（loopback test） IP地址的特点： 每个IP地址都由网络号和主机号两部分组成。 IP地址是一种分等级的地址结构 管理机构只分配网络号，主机号由使用该网络号的机构自行分配 路由器仅根据目的主机所连接的网络号来转发分组（从而减小路由表所占的存储空间以及查找路由表的时间 按照互联网的观点，一个网络是指具有相同网络号net-id的主机的集合 因此，用转发器或网桥连接起来的若干个局域网仍为一个网络 平等 4.2.3 IP地址与硬件地址 当IP数据报放入数据链路层的MAC帧中之后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址 强调： 在IP层抽象的互联网上只能看到IP数据报（即中间经过的路由器的IP地址并不出现在IP数据报的首部中 虽然IP数据报首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择 在局域网的链路层，只能看见MAC帧 4.2.4 地址解析协议ARP 已经知道一个机器（主机或路由器）的IP地址，需要找出其硬件地址 由于是IP协议使用了ARP协议，因此通常将其划分到网络层。当然，划分到数据链路层也是可以的。 ARP高速缓存 生存时间 注意，ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题 只要主机或路由器要和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP协议就会自动的把这个IP地址解析为链路层所需要的硬件地址 4.2.5 IP数据报的格式 （1）IP数据报首部固定部分的各字段 首部长度 如果是0101，则表示长度为5*4字节=20字节 区分服务：一般不使用 总长度：不超过MTU 标识（identification）：当数据报长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标志字段中。相同的标识字段的值使分片后的各数据报片最后能正确的重装为原来的数据报 标志（flag） 片偏移 每个分片的长度一定是8字节（64位）的整数倍 生存时间（TTL） 防止数据报无限制的兜圈子，现在的TTL的单位是跳数 协议 首部检验和：只检验数据报的首部，不包括数据部分 （2）可变部分 4.2.6 IP层转发分组的流程 （目的网络地址，下一跳地址） 4.3 划分子网和构造超网 4.3.1 划分子网 （1）从两级IP地址到三级IP地址 基本思路 划分子网是一个单位内部的事情，本单位以外的网络看不见这个网络由多少子网组成 从网络的主机号借用若干位作为子网号（subnet-id)，于是两级IP地址在本单位内部就变为三级网络地址 （2）子网掩码（subnet mask） 默认子网掩码 例子 4.3.2 使用子网时分组的转发 使用子网划分后，路由表必须包含：目的网络地址，子网掩码，下一跳地址 4.3.3 无分类编址CIDR（构造超网） （1）网络前缀 变长子网掩码（VLSM）variable length subnet mask 在VLSM基础上又进一步研究出 无分类编址方法 CIDR（Classless Inter-Domain routing） 特点 消除了传统的A类，B类和C类地址以及划分子网的概念：网络前缀+主机号 CIDR地址块 地址掩码 （/多少，掩码前就有几个连续的一） 注意CIDR最大最小地址的计算方法 路由聚合：路由表利用CIDR地址块来查找目的网络。减少路由器之间的路由选择信息的交换 （2）最长匹配前缀 选择最具体的 （3）使用二叉树线索查找路由表 唯一前缀 4.4 网际控制报文协议ICMP 为了更有效地转发IP数据报和提高成功交付地机会 不是高层协议 4.4.1 ICMP报文的种类 ICMP差错报文 数据字段有相同的格式 ICMP询问报文 不发送ICMP报文的几种情况 对ICMP差错报文不发送 对第一个分片的数据报片的所有后续数据报片不发送 具有多播地址的数据报 具有特殊地址（127.0.0.0或0.0.0.0） 4.4.2 ICMP应用举例 1.PING（应用层直接使用网络层ICMP） 测试两台主机之间的连通性 2.traceroute（用来跟踪一个分组从源点到终点的路径） 注意：花费的时间与经过的路由器的个数无关 4.5 互联网的路由选择协议 就是讨论路由表中的路由是怎么样得出的 4.5.1 有关路由选择协议的几个基本概念 1. 理想的路由算法 正确且完整 计算简单 自适应性（鲁棒性） 静态路由选择策略 动态路由选择策略 收敛于一个可接受的解 公平（对于用户） 最佳（较为合理） 2. 分层次的路由选择协议 互联网主要采用动态的（自适应），分布式的路由选择协议 AS（自治系统autonomous system） 内部网关协议IGP（Interior Gateway Protocol） 外部网关协议EGP（external gateway protocol） 边界网关协议BGP 域间路由选择 域内路由选择 4.5.2 内部网关协议RIP 基于距离向量的路由选择协议简单 1.工作原理 跳数（hop count） rip不能在两个网络之间同时使用多条路由，选择一条具有最少路由器的路由 特点 仅相邻路由器之间交换信息 交换的信息是本路由器的路由表 固定时间间隔 2.距离向量算法 对于每一个相邻路由器（地址为X）当前路由器地址为A发来的RIP报文： 注意，X中的目的网络为N （1）A修改X发过来的RIP报文，把下一跳地址都改为X，距离+1； （2） 若原路由表没有目的网络N，则添加 否则 若下一跳地址为X，则把收到的项目替换路由表的原项目 如不是X，则选择最短距离的那个项目 三分钟未收到，则把该路由器设为不可达距离为16表示不可达 例子 RIP协议让一个自治系统中所有的路由器和自己的相邻路由器定期交换路由信息，并不断更新路由表，使得每一个路由器到每一个目的网络的路由都是最短的 3.RIP协议的报文格式 RIP报文由首部和路由部分组成 首部占4个字节 命令字段指出报文的意义： 1表示请求路由信息 2表示对请求信息的相应或未被请求而发出的路由更新报文 首部后面0为了四字节字的对齐 地址族标识符指出所使用的地址协议 自治系统号ASN RIP2还具有简单的鉴别功能 问题 RIP的一个问题是，当网络出现故障时，要经过较长时间才能将信息传到所有的路由器（即坏消息传播的慢） 4.5.3 内部网关协议OSPF（Open Shortest Path First） 为了克服RIP的缺点在1989年开发出来的 1.OSPF协议的基本特点 Dijkstra提出的最短路径算法SPF 最重要的特征：使用分布式的链路状态协议 （1）使用洪泛法，向本自治系统中所有路由器发送信息 （2）发送的信息即与本路由器相邻的所有路由器的链路状态 （3）只有当链路发生变化时，路由器才用洪泛法发送此信息 为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统划分为若干更小的范围，区域 主干区域 区域边界路由器 主干路由器 自治系统边界路由器 OSPF直接用IP数据报传送，不用UDP 2.OSPF的五种分组类型 （1）问候分组（相邻路由器每十秒交换一次） （2）数据库描述分组 （3）链路状态请求分组 （4）链路状态更新分组：OSPF协议最核心的部分 （5）链路状态确认分组 4.5.4 外部网关协议BGP 注意：自治系统连通图是树形结构，不存在回路 4.5.5 路由器的构成 1.路由器的结构 路由选择部分也叫控制部分 分组转发部分 交换结构：根据转发表，将输入输出正确的对应起来 输入端口：1，2，3分别代表物理层，数据链路层和网络层的处理模块 输出端口 转发和路由选择的区别：转发只针对一个路由器；路由选择涉及很多路由器 2.交换结构 ","link":"https://luxuuuuuuuu.github.io/post/ji-suan-ji-wang-luo-xie-xi-ren/"}]}